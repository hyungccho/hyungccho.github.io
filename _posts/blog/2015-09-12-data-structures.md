---
layout: post
title: Sort War!
modified:
categories: blog
excerpt:
tags: []
image:
  feature:
date: 2015-09-12T15:39:55-04:00
---

#Introduction

Being able to control the way data is sorted is a powerful tool for almost any situation. Let's say that I own a company of five people. Christmas is approaching and our sales have climbed 1000% in the last year (That would be quite nice...). And as a bonus for hard work, I want to give my five loyal employees a bonus depending on how long they've been with the company. Okay, sounds simple enough. If I wanted to do this, I can possibly look in my employee database, and **sort** them by the date they started working to determine their bonuses. But then again... It is only five people. I might just remember the general timeframe they came in. Fine. Let's fast forward five years...

...Now I have a hundred employees. See where this is going? There's no way I'll remember when everyone started working. Heck, I'm not sure I'll know everyone's name at this point. In this situation, having a nifty database of employees that I can sort would allow me to hand out bonuses accordingly come Christmas. Cool. But somewhere down the line...

...Maybe I have a million employees. That's right. A million. At this point, I probably know all of five people who work in the company, and if I'm still responsible for determining and handing out bonuses, I've done something wrong. However, let's say I'm still responsible, and I haven't updated my sort method to accompany this growth. I'm using some slow sort method that might've worked fine when I had a hundred employees, but now I have a million. It takes a whole day's worth of processing to sort properly. That is unacceptable. Bonuses must be given! Because of this, I'll need a much faster sorting algorithm in work to match my needs. So let's go over some of the basic and quite commonly used sorting algorithms.

We won't be focusing on time complexities in this post (We'll go over Big O and each sorting algorithm's respective time complexities in the next post), but rather just the underlying algorithms behind each sorting technique.

The four sorts we'll do are **insertion sort**, **bubble sort**, **merge sort**, and **quick sort**.

#Insertion Sort
#Bubble Sort
#Merge Sort
#Quick Sort
